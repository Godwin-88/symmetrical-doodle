"""Strategy Orchestration Layer for Meta-Policy Control.

This module implements the strategy orchestration layer that converts
intelligence outputs into trade intents while maintaining sandboxing
constraints. It serves as a meta-controller for capital allocation
across strategies.
"""

import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
from uuid import uuid4, UUID
import numpy as np
import asyncio
from concurrent.futures import ThreadPoolExecutor

from .models import IntelligenceState, MarketData
from .rl_environment import TradingEnvironmentMDP, RLAction, ExecutionAggressiveness
from .state_assembly import CompositeStateAssembler
from .config import Config

logger = logging.getLogger(__name__)


class StrategyFamily(Enum):
    """Strategy family classifications."""
    TREND = "trend"
    MEAN_REVERSION = "mean_reversion"
    VOLATILITY = "volatility"
    MOMENTUM = "momentum"
    ARBITRAGE = "arbitrage"


class StrategyHorizon(Enum):
    """Strategy time horizons."""
    INTRADAY = "intraday"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class StrategyStatus(Enum):
    """Strategy operational status."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PAUSED = "paused"
    DEPRECATED = "deprecated"


@dataclass
class StrategyDefinition:
    """Definition of a trading strategy."""
    strategy_id: str
    name: str
    description: str
    family: StrategyFamily
    horizon: StrategyHorizon
    enabled_markets: List[str]
    
    # Parameters
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    # Risk constraints
    max_allocation: float = 1.0  # Maximum allocation weight
    max_leverage: float = 1.0
    max_drawdown: float = 0.1
    
    # Regime constraints
    enabled_regimes: List[str] = field(default_factory=list)
    regime_multipliers: Dict[str, float] = field(default_factory=dict)
    
    # Performance tracking
    historical_performance: Dict[str, float] = field(default_factory=dict)
    regime_affinity: Dict[str, float] = field(default_factory=dict)
    
    # Metadata
    status: StrategyStatus = StrategyStatus.ACTIVE
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    version: str = "1.0"


@dataclass
class TradeIntent:
    """Trade intent generated by strategy orchestration."""
    intent_id: str
    strategy_id: str
    asset_id: str
    
    # Intent details
    direction: str  # "long", "short", "close"
    size: float  # Position size
    confidence: float  # Confidence score [0, 1]
    urgency: ExecutionAggressiveness
    
    # Context
    regime_context: str
    intelligence_state_id: Optional[str] = None
    reasoning: str = ""
    
    # Metadata
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "intent_id": self.intent_id,
            "strategy_id": self.strategy_id,
            "asset_id": self.asset_id,
            "direction": self.direction,
            "size": self.size,
            "confidence": self.confidence,
            "urgency": self.urgency.value if isinstance(self.urgency, ExecutionAggressiveness) else self.urgency,
            "regime_context": self.regime_context,
            "intelligence_state_id": self.intelligence_state_id,
            "reasoning": self.reasoning,
            "timestamp": self.timestamp.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None
        }


@dataclass
class PerformanceMetrics:
    """Performance metrics for strategies."""
    strategy_id: str
    
    # Returns
    total_return: float = 0.0
    annualized_return: float = 0.0
    
    # Risk metrics
    volatility: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    var_95: float = 0.0
    
    # Regime-specific performance
    regime_performance: Dict[str, Dict[str, float]] = field(default_factory=dict)
    
    # Trade statistics
    total_trades: int = 0
    win_rate: float = 0.0
    avg_trade_return: float = 0.0
    
    # Metadata
    evaluation_period: Tuple[datetime, datetime] = field(default_factory=lambda: (
        datetime.now(timezone.utc) - timedelta(days=30),
        datetime.now(timezone.utc)
    ))
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class StrategyRegistry:
    """Registry for managing trading strategies."""
    
    def __init__(self, config: Config):
        """
        Initialize strategy registry.
        
        Args:
            config: System configuration
        """
        self.config = config
        self.strategies: Dict[str, StrategyDefinition] = {}
        self.performance_cache: Dict[str, PerformanceMetrics] = {}
        self._lock = asyncio.Lock()
        
        logger.info("Initialized strategy registry")
    
    async def register_strategy(self, strategy: StrategyDefinition) -> None:
        """
        Register a new strategy.
        
        Args:
            strategy: Strategy definition to register
        """
        async with self._lock:
            if strategy.strategy_id in self.strategies:
                logger.warning(f"Strategy {strategy.strategy_id} already exists, updating")
            
            strategy.updated_at = datetime.now(timezone.utc)
            self.strategies[strategy.strategy_id] = strategy
            
            logger.info(f"Registered strategy: {strategy.strategy_id} ({strategy.family.value})")
    
    async def get_strategy(self, strategy_id: str) -> Optional[StrategyDefinition]:
        """Get strategy by ID."""
        return self.strategies.get(strategy_id)
    
    async def list_strategies(
        self, 
        family: Optional[StrategyFamily] = None,
        status: Optional[StrategyStatus] = None,
        enabled_only: bool = True
    ) -> List[StrategyDefinition]:
        """
        List strategies with optional filtering.
        
        Args:
            family: Filter by strategy family
            status: Filter by status
            enabled_only: Only return active strategies
            
        Returns:
            List of matching strategies
        """
        strategies = list(self.strategies.values())
        
        if family:
            strategies = [s for s in strategies if s.family == family]
        
        if status:
            strategies = [s for s in strategies if s.status == status]
        elif enabled_only:
            strategies = [s for s in strategies if s.status == StrategyStatus.ACTIVE]
        
        return strategies
    
    async def update_performance(
        self, 
        strategy_id: str, 
        metrics: PerformanceMetrics
    ) -> None:
        """Update performance metrics for a strategy."""
        async with self._lock:
            self.performance_cache[strategy_id] = metrics
            
            # Update strategy's historical performance
            if strategy_id in self.strategies:
                strategy = self.strategies[strategy_id]
                strategy.historical_performance.update({
                    "sharpe_ratio": metrics.sharpe_ratio,
                    "max_drawdown": metrics.max_drawdown,
                    "total_return": metrics.total_return,
                    "volatility": metrics.volatility
                })
                strategy.updated_at = datetime.now(timezone.utc)
    
    async def get_performance(self, strategy_id: str) -> Optional[PerformanceMetrics]:
        """Get performance metrics for a strategy."""
        return self.performance_cache.get(strategy_id)
    
    async def get_strategies_for_regime(self, regime_id: str) -> List[StrategyDefinition]:
        """Get strategies suitable for a specific regime."""
        suitable_strategies = []
        
        for strategy in self.strategies.values():
            if strategy.status != StrategyStatus.ACTIVE:
                continue
            
            # Check if regime is enabled
            if strategy.enabled_regimes and regime_id not in strategy.enabled_regimes:
                continue
            
            # Check regime affinity
            if regime_id in strategy.regime_affinity:
                affinity = strategy.regime_affinity[regime_id]
                if affinity > 0.3:  # Minimum affinity threshold
                    suitable_strategies.append(strategy)
            else:
                # Default inclusion if no specific affinity data
                suitable_strategies.append(strategy)
        
        return suitable_strategies


class MetaController:
    """
    Meta-controller for strategy allocation using RL.
    
    This component uses the RL environment to learn optimal
    capital allocation across strategies based on market conditions.
    """
    
    def __init__(
        self, 
        config: Config,
        strategy_registry: StrategyRegistry,
        rl_environment: Optional[TradingEnvironmentMDP] = None
    ):
        """
        Initialize meta-controller.
        
        Args:
            config: System configuration
            strategy_registry: Strategy registry
            rl_environment: Optional RL environment (created if not provided)
        """
        self.config = config
        self.strategy_registry = strategy_registry
        self.rl_environment = rl_environment
        
        # Policy state
        self.current_allocation: Dict[str, float] = {}
        self.current_exposure_multiplier: float = 0.5
        self.current_execution_aggressiveness = ExecutionAggressiveness.MEDIUM
        
        # Performance tracking
        self.allocation_history: List[Dict[str, Any]] = []
        self.performance_history: List[Dict[str, float]] = []
        
        logger.info("Initialized meta-controller")
    
    async def initialize_rl_environment(self, strategy_ids: List[str]) -> None:
        """Initialize RL environment with strategy IDs."""
        if not self.rl_environment:
            from .rl_environment import EpisodeConfig
            
            episode_config = EpisodeConfig(
                max_steps=100,
                decision_interval_minutes=60,
                max_drawdown_threshold=0.15
            )
            
            self.rl_environment = TradingEnvironmentMDP(
                config=self.config,
                strategy_ids=strategy_ids,
                episode_config=episode_config
            )
            
            logger.info(f"Initialized RL environment with {len(strategy_ids)} strategies")
    
    async def allocate_capital(
        self, 
        intelligence_state: IntelligenceState,
        available_strategies: List[str],
        total_capital: float = 100000.0
    ) -> Dict[str, float]:
        """
        Allocate capital across strategies based on intelligence state.
        
        Args:
            intelligence_state: Current intelligence state
            available_strategies: List of available strategy IDs
            total_capital: Total capital to allocate
            
        Returns:
            Dictionary mapping strategy_id to allocated capital
        """
        if not available_strategies:
            logger.warning("No strategies available for allocation")
            return {}
        
        # Initialize RL environment if needed
        if not self.rl_environment:
            await self.initialize_rl_environment(available_strategies)
        
        # Convert intelligence state to RL action (simplified)
        # In production, this would use a trained RL policy
        allocation_weights = await self._generate_allocation_weights(
            intelligence_state, available_strategies
        )
        
        # Apply exposure multiplier based on regime confidence
        exposure_multiplier = self._calculate_exposure_multiplier(intelligence_state)
        
        # Calculate capital allocations
        allocations = {}
        for strategy_id, weight in allocation_weights.items():
            allocated_capital = total_capital * weight * exposure_multiplier
            allocations[strategy_id] = allocated_capital
        
        # Update current state
        self.current_allocation = allocation_weights
        self.current_exposure_multiplier = exposure_multiplier
        
        # Record allocation
        allocation_record = {
            "timestamp": intelligence_state.timestamp.isoformat(),
            "regime": intelligence_state.current_regime_label,
            "regime_confidence": intelligence_state.regime_confidence,
            "allocations": allocations,
            "exposure_multiplier": exposure_multiplier,
            "total_allocated": sum(allocations.values())
        }
        self.allocation_history.append(allocation_record)
        
        logger.info(f"Allocated capital across {len(allocations)} strategies")
        return allocations
    
    async def _generate_allocation_weights(
        self, 
        intelligence_state: IntelligenceState,
        strategy_ids: List[str]
    ) -> Dict[str, float]:
        """Generate allocation weights based on intelligence state."""
        # Simple heuristic-based allocation (placeholder for RL policy)
        weights = {}
        
        # Get regime-suitable strategies
        regime_strategies = []
        if intelligence_state.current_regime_label:
            regime_strategies = await self.strategy_registry.get_strategies_for_regime(
                intelligence_state.current_regime_label
            )
            regime_strategy_ids = [s.strategy_id for s in regime_strategies]
        else:
            regime_strategy_ids = strategy_ids
        
        # Filter to available strategies
        suitable_strategy_ids = [
            sid for sid in strategy_ids if sid in regime_strategy_ids
        ]
        
        if not suitable_strategy_ids:
            suitable_strategy_ids = strategy_ids  # Fallback to all strategies
        
        # Equal weight allocation with regime bias
        base_weight = 1.0 / len(suitable_strategy_ids)
        
        for strategy_id in strategy_ids:
            if strategy_id in suitable_strategy_ids:
                # Boost weight for regime-suitable strategies
                regime_boost = 1.2 if intelligence_state.regime_confidence and intelligence_state.regime_confidence > 0.7 else 1.0
                weights[strategy_id] = base_weight * regime_boost
            else:
                weights[strategy_id] = base_weight * 0.5  # Reduced weight
        
        # Normalize weights
        total_weight = sum(weights.values())
        if total_weight > 0:
            weights = {k: v / total_weight for k, v in weights.items()}
        else:
            # Equal weights fallback
            equal_weight = 1.0 / len(strategy_ids)
            weights = {sid: equal_weight for sid in strategy_ids}
        
        return weights
    
    def _calculate_exposure_multiplier(self, intelligence_state: IntelligenceState) -> float:
        """Calculate exposure multiplier based on market conditions."""
        base_exposure = 0.5
        
        # Adjust based on regime confidence
        if intelligence_state.regime_confidence:
            confidence_adjustment = (intelligence_state.regime_confidence - 0.5) * 0.4
            base_exposure += confidence_adjustment
        
        # Adjust based on embedding similarity (market familiarity)
        if intelligence_state.embedding_similarity_context:
            avg_similarity = np.mean([
                match.similarity_score 
                for match in intelligence_state.embedding_similarity_context
            ])
            similarity_adjustment = (avg_similarity - 0.5) * 0.2
            base_exposure += similarity_adjustment
        
        # Adjust based on systemic risk
        if (intelligence_state.graph_structural_features and 
            intelligence_state.graph_structural_features.systemic_risk_proxy):
            risk_adjustment = -intelligence_state.graph_structural_features.systemic_risk_proxy * 0.3
            base_exposure += risk_adjustment
        
        # Clamp to valid range
        return max(0.1, min(1.0, base_exposure))
    
    async def evaluate_performance(
        self, 
        strategy_id: str,
        evaluation_period_days: int = 30
    ) -> PerformanceMetrics:
        """
        Evaluate strategy performance over a period.
        
        Args:
            strategy_id: Strategy to evaluate
            evaluation_period_days: Evaluation period in days
            
        Returns:
            Performance metrics
        """
        # Mock performance evaluation
        # In production, this would analyze actual trade results
        
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(days=evaluation_period_days)
        
        # Generate mock performance metrics
        np.random.seed(hash(strategy_id) % 2**32)  # Deterministic for strategy
        
        daily_returns = np.random.normal(0.0005, 0.02, evaluation_period_days)  # ~0.05% daily mean
        cumulative_return = np.prod(1 + daily_returns) - 1
        
        volatility = np.std(daily_returns) * np.sqrt(252)
        sharpe_ratio = np.mean(daily_returns) / (np.std(daily_returns) + 1e-8) * np.sqrt(252)
        
        # Calculate drawdown
        cumulative_values = np.cumprod(1 + daily_returns)
        running_max = np.maximum.accumulate(cumulative_values)
        drawdowns = (cumulative_values - running_max) / running_max
        max_drawdown = np.min(drawdowns)
        
        metrics = PerformanceMetrics(
            strategy_id=strategy_id,
            total_return=cumulative_return,
            annualized_return=cumulative_return * (365 / evaluation_period_days),
            volatility=volatility,
            sharpe_ratio=sharpe_ratio,
            max_drawdown=abs(max_drawdown),
            var_95=np.percentile(daily_returns, 5),
            total_trades=evaluation_period_days // 2,  # Mock trade count
            win_rate=0.55 + np.random.normal(0, 0.1),  # Mock win rate
            avg_trade_return=np.mean(daily_returns),
            evaluation_period=(start_date, end_date)
        )
        
        # Update registry
        await self.strategy_registry.update_performance(strategy_id, metrics)
        
        return metrics


class StrategyOrchestrator:
    """
    Main orchestration layer that coordinates strategy selection,
    capital allocation, and trade intent generation.
    """
    
    def __init__(self, config: Config):
        """
        Initialize strategy orchestrator.
        
        Args:
            config: System configuration
        """
        self.config = config
        self.strategy_registry = StrategyRegistry(config)
        self.meta_controller = MetaController(config, self.strategy_registry)
        self.state_assembler = CompositeStateAssembler(config)
        
        # Intent tracking
        self.active_intents: Dict[str, TradeIntent] = {}
        self.intent_history: List[TradeIntent] = []
        
        # Performance monitoring
        self.orchestration_metrics: Dict[str, Any] = {}
        
        logger.info("Initialized strategy orchestrator")
    
    async def initialize_default_strategies(self) -> None:
        """Initialize default strategy definitions."""
        default_strategies = [
            StrategyDefinition(
                strategy_id="trend_following_1h",
                name="Trend Following 1H",
                description="Hourly trend following strategy using moving averages",
                family=StrategyFamily.TREND,
                horizon=StrategyHorizon.INTRADAY,
                enabled_markets=["EURUSD", "GBPUSD", "USDJPY"],
                parameters={"fast_ma": 12, "slow_ma": 26, "signal_ma": 9},
                max_allocation=0.3,
                enabled_regimes=["low_vol_trending", "high_vol_trending"],
                regime_multipliers={"low_vol_trending": 1.2, "high_vol_trending": 0.8}
            ),
            StrategyDefinition(
                strategy_id="mean_reversion_4h",
                name="Mean Reversion 4H",
                description="4-hour mean reversion strategy using RSI",
                family=StrategyFamily.MEAN_REVERSION,
                horizon=StrategyHorizon.INTRADAY,
                enabled_markets=["EURUSD", "GBPUSD"],
                parameters={"rsi_period": 14, "oversold": 30, "overbought": 70},
                max_allocation=0.25,
                enabled_regimes=["low_vol_ranging", "high_vol_ranging"],
                regime_multipliers={"low_vol_ranging": 1.3, "high_vol_ranging": 0.9}
            ),
            StrategyDefinition(
                strategy_id="volatility_breakout_1d",
                name="Volatility Breakout Daily",
                description="Daily volatility breakout strategy",
                family=StrategyFamily.VOLATILITY,
                horizon=StrategyHorizon.DAILY,
                enabled_markets=["EURUSD", "GBPUSD", "USDJPY", "AUDUSD"],
                parameters={"lookback_period": 20, "breakout_threshold": 2.0},
                max_allocation=0.2,
                enabled_regimes=["high_vol_trending", "high_vol_ranging"],
                regime_multipliers={"high_vol_trending": 1.1, "high_vol_ranging": 1.0}
            )
        ]
        
        for strategy in default_strategies:
            await self.strategy_registry.register_strategy(strategy)
        
        logger.info(f"Initialized {len(default_strategies)} default strategies")
    
    async def orchestrate_strategies(
        self, 
        asset_id: str,
        recent_market_data: List[MarketData],
        total_capital: float = 100000.0
    ) -> List[TradeIntent]:
        """
        Main orchestration method that generates trade intents.
        
        Args:
            asset_id: Primary asset identifier
            recent_market_data: Recent market data for analysis
            total_capital: Total available capital
            
        Returns:
            List of generated trade intents
        """
        logger.info(f"Orchestrating strategies for {asset_id}")
        
        # Assemble current intelligence state
        intelligence_state = await self.state_assembler.assemble_intelligence_state(
            asset_id, recent_market_data
        )
        
        # Get available strategies
        available_strategies = await self.strategy_registry.list_strategies(
            enabled_only=True
        )
        strategy_ids = [s.strategy_id for s in available_strategies]
        
        if not strategy_ids:
            logger.warning("No active strategies available")
            return []
        
        # Allocate capital across strategies
        allocations = await self.meta_controller.allocate_capital(
            intelligence_state, strategy_ids, total_capital
        )
        
        # Generate trade intents for each allocated strategy
        trade_intents = []
        
        for strategy_id, allocated_capital in allocations.items():
            if allocated_capital <= 0:
                continue
            
            strategy = await self.strategy_registry.get_strategy(strategy_id)
            if not strategy:
                continue
            
            # Generate intent for this strategy
            intent = await self._generate_trade_intent(
                strategy, asset_id, allocated_capital, intelligence_state
            )
            
            if intent:
                trade_intents.append(intent)
                self.active_intents[intent.intent_id] = intent
        
        # Record orchestration metrics
        self.orchestration_metrics = {
            "timestamp": intelligence_state.timestamp.isoformat(),
            "asset_id": asset_id,
            "regime": intelligence_state.current_regime_label,
            "strategies_considered": len(strategy_ids),
            "intents_generated": len(trade_intents),
            "total_allocated": sum(allocations.values()),
            "allocation_efficiency": sum(allocations.values()) / total_capital
        }
        
        logger.info(f"Generated {len(trade_intents)} trade intents")
        return trade_intents
    
    async def _generate_trade_intent(
        self,
        strategy: StrategyDefinition,
        asset_id: str,
        allocated_capital: float,
        intelligence_state: IntelligenceState
    ) -> Optional[TradeIntent]:
        """Generate trade intent for a specific strategy."""
        # Check if asset is enabled for this strategy
        if asset_id not in strategy.enabled_markets:
            return None
        
        # Check regime compatibility
        current_regime = intelligence_state.current_regime_label
        if (strategy.enabled_regimes and current_regime and 
            current_regime not in strategy.enabled_regimes):
            return None
        
        # Calculate position size based on allocation and risk limits
        max_position_size = allocated_capital * strategy.max_leverage
        
        # Apply regime multiplier if available
        regime_multiplier = 1.0
        if current_regime and current_regime in strategy.regime_multipliers:
            regime_multiplier = strategy.regime_multipliers[current_regime]
        
        position_size = max_position_size * regime_multiplier
        
        # Determine direction based on strategy family and market conditions
        direction = self._determine_trade_direction(strategy, intelligence_state)
        
        # Calculate confidence based on regime confidence and strategy affinity
        base_confidence = intelligence_state.regime_confidence or 0.5
        strategy_affinity = strategy.regime_affinity.get(current_regime, 0.5) if current_regime else 0.5
        confidence = (base_confidence + strategy_affinity) / 2
        
        # Determine execution urgency
        urgency = self._determine_execution_urgency(strategy, intelligence_state)
        
        # Create trade intent
        intent = TradeIntent(
            intent_id=str(uuid4()),
            strategy_id=strategy.strategy_id,
            asset_id=asset_id,
            direction=direction,
            size=position_size,
            confidence=confidence,
            urgency=urgency,
            regime_context=current_regime or "unknown",
            intelligence_state_id=str(uuid4()),  # Would be actual state ID
            reasoning=f"Strategy {strategy.name} in regime {current_regime} with confidence {confidence:.2f}",
            expires_at=datetime.now(timezone.utc) + timedelta(hours=1)
        )
        
        return intent
    
    def _determine_trade_direction(
        self, 
        strategy: StrategyDefinition, 
        intelligence_state: IntelligenceState
    ) -> str:
        """Determine trade direction based on strategy and market state."""
        # Simplified direction logic based on strategy family
        if strategy.family == StrategyFamily.TREND:
            # Trend strategies: use regime information
            if intelligence_state.current_regime_label:
                if "trending" in intelligence_state.current_regime_label.lower():
                    return "long"  # Assume uptrend for simplicity
                else:
                    return "close"  # Close positions in ranging markets
            return "long"
        
        elif strategy.family == StrategyFamily.MEAN_REVERSION:
            # Mean reversion: opposite to trend
            if intelligence_state.current_regime_label:
                if "ranging" in intelligence_state.current_regime_label.lower():
                    return "short"  # Assume mean reversion opportunity
                else:
                    return "close"
            return "short"
        
        elif strategy.family == StrategyFamily.VOLATILITY:
            # Volatility strategies: active in high vol regimes
            if intelligence_state.current_regime_label:
                if "high_vol" in intelligence_state.current_regime_label.lower():
                    return "long"
                else:
                    return "close"
            return "close"
        
        else:
            return "close"  # Conservative default
    
    def _determine_execution_urgency(
        self, 
        strategy: StrategyDefinition, 
        intelligence_state: IntelligenceState
    ) -> ExecutionAggressiveness:
        """Determine execution urgency based on strategy and market conditions."""
        # Base urgency on strategy horizon
        if strategy.horizon == StrategyHorizon.INTRADAY:
            base_urgency = ExecutionAggressiveness.HIGH
        elif strategy.horizon == StrategyHorizon.DAILY:
            base_urgency = ExecutionAggressiveness.MEDIUM
        else:
            base_urgency = ExecutionAggressiveness.LOW
        
        # Adjust based on regime confidence
        if intelligence_state.regime_confidence and intelligence_state.regime_confidence < 0.5:
            # Lower urgency in uncertain regimes
            if base_urgency == ExecutionAggressiveness.HIGH:
                return ExecutionAggressiveness.MEDIUM
            elif base_urgency == ExecutionAggressiveness.MEDIUM:
                return ExecutionAggressiveness.LOW
        
        return base_urgency
    
    async def get_orchestration_status(self) -> Dict[str, Any]:
        """Get current orchestration status and metrics."""
        active_strategies = await self.strategy_registry.list_strategies(enabled_only=True)
        
        return {
            "active_strategies": len(active_strategies),
            "active_intents": len(self.active_intents),
            "total_intents_generated": len(self.intent_history),
            "last_orchestration": self.orchestration_metrics,
            "strategy_families": {
                family.value: len([s for s in active_strategies if s.family == family])
                for family in StrategyFamily
            }
        }
    
    async def close(self) -> None:
        """Close orchestrator and cleanup resources."""
        await self.state_assembler.close()
        if self.meta_controller.rl_environment:
            await self.meta_controller.rl_environment.close()
        logger.info("Strategy orchestrator closed")


# Utility functions for testing and validation

def create_sample_strategy() -> StrategyDefinition:
    """Create a sample strategy for testing."""
    return StrategyDefinition(
        strategy_id="sample_strategy",
        name="Sample Strategy",
        description="A sample strategy for testing",
        family=StrategyFamily.TREND,
        horizon=StrategyHorizon.INTRADAY,
        enabled_markets=["EURUSD"],
        parameters={"param1": 1.0, "param2": 2.0},
        max_allocation=0.5
    )


async def validate_orchestration_components(orchestrator: StrategyOrchestrator) -> Dict[str, bool]:
    """
    Validate orchestration components.
    
    Args:
        orchestrator: Orchestrator to validate
        
    Returns:
        Dictionary of validation results
    """
    results = {}
    
    # Test strategy registry
    try:
        sample_strategy = create_sample_strategy()
        await orchestrator.strategy_registry.register_strategy(sample_strategy)
        retrieved = await orchestrator.strategy_registry.get_strategy(sample_strategy.strategy_id)
        results["strategy_registry_works"] = retrieved is not None
    except Exception as e:
        logger.error(f"Strategy registry validation failed: {e}")
        results["strategy_registry_works"] = False
    
    # Test meta-controller initialization
    try:
        await orchestrator.meta_controller.initialize_rl_environment(["test_strategy"])
        results["meta_controller_initializes"] = True
    except Exception as e:
        logger.error(f"Meta-controller validation failed: {e}")
        results["meta_controller_initializes"] = False
    
    # Test performance evaluation
    try:
        metrics = await orchestrator.meta_controller.evaluate_performance("test_strategy")
        results["performance_evaluation_works"] = isinstance(metrics, PerformanceMetrics)
    except Exception as e:
        logger.error(f"Performance evaluation failed: {e}")
        results["performance_evaluation_works"] = False
    
    return results